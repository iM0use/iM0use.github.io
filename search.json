[{"title":"acm_solve","date":"2022-05-18T16:38:56.000Z","url":"/2022/05/19/acm_solve/","content":"马上省赛，为了应付一下这个考试，得看看往年题，总结一下经验。 B. Build Roads一个王国，有n个城市。想建n-1条边连接城市，第i个城市有一个建筑公司经验值为ai。想在i和j城市之间建一条路，需要两个城市的建筑公司互相竞争，在修路中两家公司会起冲突，从而造成材料浪费。浪费材料为gcd(ai,aj) 请设计一条路连接n个城市用n条边，花费最少。 分析：如果R = L，那么ai = L，相邻城市之间花费L，总花费L*(n-1)。如果R ≠ L，n较小时暴力连边建生成树(n^2)；如果n较大，若R - L + 1较大，根据素数分布，素数相距大概几百左右，这样L到(R - L + 1) + L之间必然有一个素数，有一个数为素数，gcd就为1，答案为(n - 1)，若R - L + 1较小，R - L + 1区间之内会被取满，根据连续的两个数必然互质可得结果仍然为(n - 1)。 暴力建树，单向建边，取其中任意n-1条边一定会把n个城市给连在一起。所以不需要并查，直接排序依据最小权取n-1个即可。 C. Cat Virus一个国家，有很多族可以被视为有根树。一个族包含黑色和白色，改族新生儿可能是黑色，如果一个新生儿是黑色，那么它的后代也是黑色。 给一个整数k，可以有k种方式标记黑色和白色组成家族成员。两种方式肯定有不完全相同的成员，至少有一个黑色，而另一个为白色。 问如何建一个有根树使得方式为k。 设f(u)为染色u及u所有子树的方案树，若将u染成黑色，则只有一种方案，若将u染成白色，则设u的子节点为v，f(u)=proc(f(v))+1，u方案数为子树方案数之积在加上黑色的一种方案。各子树之间互不影响，所以是乘积。 若k为奇数，我们给k弄一个左儿子和右儿子，向右儿子方向走，f(r) = (k - 1) / 2，f(l) = 2, f(u) = f(l) * f(r) + 1，若k为偶数，我们直接让u连接一个子节点，然后到下一层，方案数边成k - 1。 D. Dyson Box一个盒子二维方格，左下角坐标为（0，0），右上角坐标为（2×10 ^ 5，2×10 ^ 5）。 将有n个事件发生，第i次事件时出现一个立方体，左下角坐标为（xi-1，yi-1），右上角坐标为（xi，yi）。 盒子里有两个地心引力的方向，水平和竖直，有一半的可能是水平，剩下一半是竖直。她开始测量所有立方体轮廓的总长。如果引力方向是水平，所有立方体水平向左移动，如果是竖直，则竖直向下移动。 计算每次事件后两种情况（两种情况是指向左移动或向下移动）的轮廓总长。 对于竖直情况，当已经有一块，添加下一块时要减去2，对于旁边的两列，如果旁边两栋大楼更高，就减2。 F. Birthday Cake请帮助Yamabuki分蛋糕，Yamabuki有n种不同的蛋糕，可以用小写拉丁字母表示，表示蛋糕上面有什么，字符串的拼接表示蛋糕的合并。 若AB满足CC结构，（A，B两个字符串拼接后可以拆成两个相同的字符串即满足此规律），若AB满足，则BA也满足，所以枚举A的时候找可以满足条件的B即可。 "},{"title":"HITCON-train-hacknote","date":"2022-05-18T14:43:16.000Z","url":"/2022/05/18/HITCON-train-hacknote/","content":" 一个写笔记的程序，下面是程序的一些功能。 因为想去弄懂一些细节，所以在GitHub上搜到了源代码。 顺便看看并总结angelboy大神的幻灯片，分享收获。 The workflow of malloc 第一次执行 malloc 无论一开始 malloc 多少空间 &lt; 128 KB 都会有 kernel 给132 KB 的 heap segment (rw) 这部分为 main arena 第二次执行 malloc 时，只要分配的空间大小不超过 128 KB，则不再执行 system call 跟系统要空间，超过大小才会有 brk 从kernel 索要空间存储。 即使 free 掉所有 main arena 分配的空间，也不会立即还给 kernel 这时存储空间由 glibc 管理 Mechanism of glibc malloc Chunk glibc 在用作存储管理时的数据结构 malloc 时分配出去的为一个 chunk chunk header（prev_size + size）+ user data 如果该 chunk 被 free 则会将 chunk 加入叫做 bin 的链表里 分类 ​ Allocated chunk ​ Free chunk ​ Top chunk heap Allocated chunk prev_size 如果上一个的 chunk 是 freed，则该位置上会存有上一个 chunk 的 size（包括 header） 这里指的上一个是在连续存储的上一个 size 该 chunk 大小，其中有三个 flag PREV_INUSE (bit 0): 上一个 chunk 是否不是 freed IS_MMAPPED (bit 1): 该 chunk 是不是由 mmap 所分配出去的 NON_MAIN_ARENA (bit 2): 是否不属于 main arena 图 free chunk prev_size size fd : point to next chunk（包括 bin） 这里指的是链表中的 next chunk，而非连续存储的 chunk bk : point to last chunk（包括 bin） 这里指的是链表中的 last chunk，而非连续存储的 chunk fd_nextsize : point to next large chunk（不包含 bin） bk_nextsize : point to last large chunk（不包含 bin） freed chunk top chunk 第一次 malloc 时就会将 heap 切成两块 chunk，第一个 chunk 就是分配出去的 chunk，剩下的空间被视为 top chunk，之后要是分配空间不足时会有 top chunk 切出去 prev_size "},{"title":"blog-newcomer","date":"2022-05-17T16:38:56.000Z","url":"/2022/05/18/blog-newcomer/","content":""}]