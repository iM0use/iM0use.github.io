[{"title":"mips-jr","date":"2022-06-18T14:43:16.000Z","url":"/2022/06/18/mips_jr/","content":" overviewInstructionThe Jump Register instruction causes the PC to jump to the contents of the first source register. syntax take a sample: JR $13 binary expression length Opcode: 6 rs: 5 rt: 5 rd: 5 shamt: 5 funct: 6 length_all = 6+5+5+5+5+6 = 32 if we make $13 register’s value equals to 789 in decmical, so we can find some information on $13 Register’s Address Register’s Address (Binary) Register’s Value Register’s Value (Hexadecimal) $13 01101 789 00000315 procedure This simple datapath is of a single-cycle nature. The instruction begins with the PC. PC value set to 00000114H The PC’s value, as well as a fixed value necessary to increase the PC by one cycle are passed into the ALU. The address of the instruction to be executed is passed to the IM. The Adder performs an arithmetic add operation to determine the next PC value. On the other hand, the instruction is decoded by the IM. IM: Fetching instruction from 00000114H: 000000 01101 00000 00000 00000 001000B Adder: Add 00000004H to 00000114H. The decoded instruction is split into different corresponding segments and sent to the RF. The function bits are sent to the ALU Control, and the opcode is sent to the Control Unit. The RF retrieves the data from the register required by the instruction. The CU identifies the type of instruction it is via the opcode. Control Unit: Opcode 000000B, Instruction: R type Read $13(01101B)’s value of 000001CDH The Adder sends the new PC value to the MUX. The RF sends the read data to the ALU and the MUX. new PC: 00000118H=00000004H+00000114H JRsel = 1B From the JRsel signal sent by the CU, the MUX selects the input from the RF to be the next PC value. The MUX sends the new PC value to the PC. source netdoor This source is very nice and interest. It make the abstract knowledge animated."},{"title":"HITCON-train-hacknote","date":"2022-06-18T14:43:16.000Z","url":"/2022/06/18/pwnable/","content":" calc 运行测试 借助测试可以发现一些规则，比如输入 0 会发生“prevent division by zero”信息，输入字母也不能计算，只输入字母会直接退出。 会出现一些干扰利用的东西，我们直接来到 eval ，这个函数承担计算的主要功能。简化一下。 *initpool 保存当前运算数个数。 假如当前运算符为+或-，读到上面第 16 行的 eval 需要满足什么条件？(unsigned int)(*(char *)(i + expr) - 48) &gt; 9 &amp;&amp; strcmp(prev_nums_str, \"0\") &amp;&amp; ( *(_BYTE *)(i + expr) &amp;&amp; (unsigned int)(*(char *)(i + 1 + expr) - 48) &gt; 9 ) &amp;&amp; operator[prev] &amp;&amp; ( *(_BYTE *)(i + expr) == '+' || *(_BYTE *)(i + expr) == '-') 现在指针（i + expr）指向的是运算符。 指针前面的数字（prev_nums_str）不能是 0，因为这里是 memcpy 复制过来的数字所以是字符串不能为 “0”。 指针的下一位（i + 1 + expr）不能是运算符，即两个运算符不能挨在一起。 operator 里存放有运算符 现在指针所指向运算符为 + 或者 - 然后应该是运算上一个数和上上一个数的运算公式。 如果是第一次遇到运算符，如何处理？ 如果是 “%*/“ 中的一个运算符且前一个运算符也是，eval(initpool, operator[prev]); operator[prev] = *(_BYTE *)(i + expr);，可以看见这种运算符用完就丢掉。 breakpoint： 0x8049130：prev_nums = atoi(prev_nums_str); 0x8049354：while ( prev &gt;= 0 ) eval(initpool, operator[prev--]); 0x804928A：operator[++prev] = *(_BYTE *)(i + expr);现”%*/“，上一位”+-“ 0x804922C：eval(nums, operator[prev]);连续非+-号 0x804922A：default 0x80491E3：operator[seqopr] = *(_BYTE *)(i + expr);存符号 "},{"title":"input2","date":"2022-06-10T14:43:16.000Z","url":"/2022/06/10/input2/","content":" Stage 1 clear!Firstly, there has argv. It sames like that behind. such as /bin/ls -l: left one represent argv[0], right one represent argv[1], …etc. argc represent the length of argv list. So in order to satisfy strcmp(argv['A'],\"\\x00\") != 0, I can set argv['A'] = \"\\x00\", and next condition. Stage 2 clear!stdio: standard input/output It uses the read. read - read from a file descriptor include: unistd.h ssize_t read(int fd, void *buf, size_t count); 整数值 名称 unistd.h符号常量 stdio.h文件流 0 Standard input STDIN_FILENO stdin 1 Standard output STDOUT_FILENO stdout 2 Standard error STDERR_FILENO stderr read(0, buf, 4);: read 4 bytes from stdin read(2, buf, 4);: read 2 bytes from stderr We can easily use pwntools to start our play. This tool we need called process. We can create program. Cation! stderr_we_want=\"\\x00\\x0a\\x02\\xff\" can’t work well. stderr is a file descriptor. open return file descriptor, we can hand it. Stage 3 clear!also use process. Stage 4 clear!It open a file named \\x0a that mean newline in program, but don’t care it. Start to write in file like Stage 2. fread size_t fread(void *__restrict__ __ptr, size_t __size, size_t __n, FILE *__restrict__ __stream) Read chunks of generic data from STREAM. return: This number equals the number of bytes transferred only when size is 1. If an error occurs, or the end of the file is reached, the return value is a short item count (or zero). memcpy int memcmp(const void *__s1, const void *__s2, size_t __n) Compare N bytes of S1 and S2. Stage 5 clear!create a new endpoint for communication, usually 127.0.0.1 as host, 9999 as port(out can link). use remote in pwntools. AF_INET: IPv4 Internet protocols, remote support both IPv4 and IPv6. INADDR_ANY: \\#define INADDR_ANY ((in_addr_t) 0x00000000), we can use any address we want. htons( atoi(argv['C']) ): depend on we set value on argv['C'] bind bind a name to a socket int bind(int __fd, const struct sockaddr *__addr, socklen_t __len) Traditionally, this operation is called “assigning a name to a socket”. code: OMG! one write the exp in /tmp/pwn，admin’s soltion exp os.pipe: create a pipe,return (rear, write), left one is “read out”, right one is “write in”. "},{"title":"HITCON-train","date":"2022-06-08T14:43:16.000Z","url":"/2022/06/08/hitcon-train/","content":" HITCON-TrainingFor Linux binary Exploitation Environment Setup Outline Basic Knowledge Introduction Reverse Engineering Static Analysis Dynamic Analysis Exploitation Useful Tool IDA PRO GDB Pwntool lab 1 - sysmagic Section Compile,linking,assmbler Execution how program get run Segment x86 assembly Calling convention lab 2 - open/read/write shellcoding Stack Overflow Buffer Overflow Return to Text/Shellcode lab 3 - ret2shellcode Protection ASLR/DEP/PIE/StackGuard Lazy binding Return to Library lab 4 - ret2lib Return Oriented Programming ROP lab 5 - simple rop Using ROP bypass ASLR ret2plt Stack migration lab 6 - migration Format String Attack Format String Read from arbitrary memory lab 7 - crack Write to arbitrary memory lab 8 - craxme Advanced Trick EBP chain lab 9 - playfmt x64 Binary Exploitation x64 assembly ROP Format string Attack Heap exploitation Glibc memory allocator overview Vulnerablility on heap Use after free lab 10 - hacknote Heap overflow house of force lab 11 - 1 - bamboobox1 unlink lab 11 - 2 - bamboobox2 Advanced heap exploitation Fastbin attack lab 12 - babysecretgarden Shrink the chunk Extend the chunk lab 13 - heapcreator Unsortbin attack lab 14 - magicheap C++ Exploitation Name Mangling Vtable fucntion table Vector &amp; String New &amp; delete Copy constructor &amp; assignment operator lab 15 - zoo 那些 Pwning 的奇淫技巧: write upLAB 1 [sysmagic] 简单的 Symbolic Execution 反编译发现输入buf == v2，buf是随机数，可以直接gdb调试。 断点 0x08048712 &lt;+375&gt;: call 0x8048480 &lt;__isoc99_scanf@plt&gt;，然后随便输入一个值， 其实我在想另一种方法，就是既然变量都在程序里，我们也可以手动计算。 LAB 2 [orw.bin]syscall : shellcode跟pwnable.tw的orw应该是同一题，翻了翻互联网的wp，记录一下。 main orw_seccomp 关注prctl 系统过滤，系统调用函数中只有open，read，write能够进入下一步。 参考一个师傅的做法，首先使用open打开flag，然后用read读取flag，最后通过stdout输出到屏幕。 我的观察： eax作为返回值，当我们传入open(path)返回的文件描述符（见pwnable.kr的fd），一个FILE流的句柄，可以有该句柄读入到另一个寄存器(edi还是esp都可以，我们只是需要一个地址去存放)。 对于汇编的知识，"},{"title":"malloc","date":"2022-06-05T14:43:16.000Z","url":"/2022/06/05/malloc/","content":"There are some cases about heap you want. 0x01 System call - mmap, brk malloc get memory firstly system calls - ask the kernel directly mmap() ask kernel give us some new virtual addresses brk() change data segment size process doesn’t care how the memory is implemented. allocated memory through Linux Kernel and CPU's MMU etc map to process. Then process can transparently access these memory. In CTF match, we use very little space to malloc, so brk system call doesn’t appear. How malloc work? 0x02 malloc implementEasily we consider the large region as heap. Now, we want a size 8 memory to write some chars like AAAABBBB. use malloc(8). Then return a address can be writed. If malloc(8) again, what will happen guess if this is reality, some questions here. how does malloc know what address to return? how does malloc know which areas are still free? some implement here. DLmallocmost common use in malloc. workflow store for each chunk it blocks the size of chunk right before it. keep 4 bytes before chunk (before freed) first malloc return address can be calculated equal 0x804000+0x8=0x804008 Then, how does malloc know the next address after called where the next chunk can be placed? If start of the free/available area: 0x804000, next chunk address at start + now_chunk_size, so at 0x804000 + 0x10(size) = 0x804010. The will happen at malloc of system calls. So there is a point somewhere at always point to a free memory. Given the returned address of malloc, what can we do with that? Writable data addr: this pointer points to the start where we can write data to. Size of chunk: before writable data addr. Next chunk addr: start of current chunk addr add size of this chunk 0x03 small code casesheap1.c objective -&gt; winner struct internet first member: priority, (type): int second member: name, (type): char point (means contain a point to a string somewhere else) *pointer(meaning: contains an address) In 32-Bit machine, point size(a address size) equal 4 bits, but 8 bits in 64-Bit machine. malloc(sizeof(struct internet))So a chunk size: 4(int) + 4(char *) = 8 (tests in 32Bit) i1-&gt;priority = 1; write 1 to the first 4 byte of the allocated area. name point at offset = 4 of i1 object(name point at: i1 + 4).i1-&gt;name = malloc(8);Then it allocates another 8 byte, and the resulting address will stored in the char point name. Those 8 bytes are intended to store a list of characters. As a programmer, we use i1-&gt;name to access name member property. As simply going to a certain offset of i1, in this case i1+4 is the location of the char point name. i1-&gt;name [(0x804d198+8)+4]. [num] express access address in the num address which means fetch info indirectly. i2 looks like i1. We enable the argv[1] = \"aaaabbbb\", argv[2] = \"aaaabbbb\";, so heap info behind. a dangerous function! strcpy strcpy has no length check. So we can overflow name when write over 8 byte and really screw up stuff. size low bit indicate that the PREVIOUS chunk is used, so we find it is 0x11 not 0x10. That becomes more important for the free() The dlmalloc is not really the original dlmalloc. It is usually referred to as ptmalloc. 0x04 overwriteheap overflow works not well. overwrite somewhat? It actually is called got overwrite. GOT - _GLOBAL_OFFSET_TABLE_ : record function offset in program running. function call use the plt addr. we need pad some chars to overwrite the i2 name point address. it looks like this. If we write on i2 name, what will happen? so payload or "},{"title":"unlink","date":"2022-06-01T14:43:16.000Z","url":"/2022/06/01/unlink/","content":""},{"title":"pwn way","date":"2022-05-22T15:39:01.000Z","url":"/2022/05/22/pwn-way/","content":"hitcon train hitcon bilibili wpbash-c:  pwnable.krpwnable.tw 这些学完岂不是神中神， 可惜学不得。 how2heap"},{"title":"acm_solve","date":"2022-05-18T16:38:56.000Z","url":"/2022/05/19/acm_solve/","content":"马上省赛，为了应付一下这个考试，得看看往年题，总结一下经验。 B. Build Roads一个王国，有n个城市。想建n-1条边连接城市，第i个城市有一个建筑公司经验值为ai。想在i和j城市之间建一条路，需要两个城市的建筑公司互相竞争，在修路中两家公司会起冲突，从而造成材料浪费。浪费材料为gcd(ai,aj) 请设计一条路连接n个城市用n条边，花费最少。 分析：如果R = L，那么ai = L，相邻城市之间花费L，总花费L*(n-1)。如果R ≠ L，n较小时暴力连边建生成树(n^2)；如果n较大，若R - L + 1较大，根据素数分布，素数相距大概几百左右，这样L到(R - L + 1) + L之间必然有一个素数，有一个数为素数，gcd就为1，答案为(n - 1)，若R - L + 1较小，R - L + 1区间之内会被取满，根据连续的两个数必然互质可得结果仍然为(n - 1)。 暴力建树，单向建边，取其中任意n-1条边一定会把n个城市给连在一起。所以不需要并查，直接排序依据最小权取n-1个即可。 C. Cat Virus一个国家，有很多族可以被视为有根树。一个族包含黑色和白色，改族新生儿可能是黑色，如果一个新生儿是黑色，那么它的后代也是黑色。 给一个整数k，可以有k种方式标记黑色和白色组成家族成员。两种方式肯定有不完全相同的成员，至少有一个黑色，而另一个为白色。 问如何建一个有根树使得方式为k。 设f(u)为染色u及u所有子树的方案树，若将u染成黑色，则只有一种方案，若将u染成白色，则设u的子节点为v，f(u)=proc(f(v))+1，u方案数为子树方案数之积在加上黑色的一种方案。各子树之间互不影响，所以是乘积。 若k为奇数，我们给k弄一个左儿子和右儿子，向右儿子方向走，f(r) = (k - 1) / 2，f(l) = 2, f(u) = f(l) * f(r) + 1，若k为偶数，我们直接让u连接一个子节点，然后到下一层，方案数边成k - 1。 D. Dyson Box一个盒子二维方格，左下角坐标为（0，0），右上角坐标为（2×10 ^ 5，2×10 ^ 5）。 将有n个事件发生，第i次事件时出现一个立方体，左下角坐标为（xi-1，yi-1），右上角坐标为（xi，yi）。 盒子里有两个地心引力的方向，水平和竖直，有一半的可能是水平，剩下一半是竖直。她开始测量所有立方体轮廓的总长。如果引力方向是水平，所有立方体水平向左移动，如果是竖直，则竖直向下移动。 计算每次事件后两种情况（两种情况是指向左移动或向下移动）的轮廓总长。 对于竖直情况，当已经有一块，添加下一块时要减去2，对于旁边的两列，如果旁边两栋大楼更高，就减2。 F. Birthday Cake请帮助Yamabuki分蛋糕，Yamabuki有n种不同的蛋糕，可以用小写拉丁字母表示，表示蛋糕上面有什么，字符串的拼接表示蛋糕的合并。 若AB满足CC结构，（A，B两个字符串拼接后可以拆成两个相同的字符串即满足此规律），若AB满足，则BA也满足，所以枚举A的时候找可以满足条件的B即可。 "},{"title":"Dest0g3-begin","date":"2022-05-18T14:43:16.000Z","url":"/2022/05/18/Dest0g3-begin/","content":" simple xor babyrsa babyaes 你知道js吗file 发现是 word 文档，然后换成其他字体，复制到 base64 解码，然后 brainfuck，然后在解码。"},{"title":"HITCON-train-hacknote","date":"2022-05-18T14:43:16.000Z","url":"/2022/05/18/HITCON-train-hacknote/","content":" 一个写笔记的程序，下面是程序的一些功能。 因为想去弄懂一些细节，所以在GitHub上搜到了源代码。 顺便看看并总结angelboy大神的幻灯片，分享收获。 The workflow of malloc 第一次执行 malloc 无论一开始 malloc 多少空间 &lt; 128 KB 都会有 kernel 给132 KB 的 heap segment (rw) 这部分为 main arena 第二次执行 malloc 时，只要分配的空间大小不超过 128 KB，则不再执行 system call 跟系统要空间，超过大小才会有 brk 从kernel 索要空间存储。 即使 free 掉所有 main arena 分配的空间，也不会立即还给 kernel 这时存储空间由 glibc 管理 Mechanism of glibc malloc Chunk glibc 在用作存储管理时的数据结构 malloc 时分配出去的为一个 chunk chunk header（prev_size + size）+ user data 如果该 chunk 被 free 则会将 chunk 加入叫做 bin 的链表里 分类 ​ Allocated chunk ​ Free chunk ​ Top chunk heap Allocated chunk prev_size 如果上一个的 chunk 是 freed，则该位置上会存有上一个 chunk 的 size（包括 header） 这里指的上一个是在连续存储的上一个 size 该 chunk 大小，其中有三个 flag PREV_INUSE (bit 0): 上一个 chunk 是否不是 freed IS_MMAPPED (bit 1): 该 chunk 是不是由 mmap 所分配出去的 NON_MAIN_ARENA (bit 2): 是否不属于 main arena 图 free chunk prev_size size fd : point to next chunk（包括 bin） 这里指的是链表中的 next chunk，而非连续存储的 chunk bk : point to last chunk（包括 bin） 这里指的是链表中的 last chunk，而非连续存储的 chunk fd_nextsize : point to next large chunk（不包含 bin） bk_nextsize : point to last large chunk（不包含 bin） freed chunk top chunk 第一次 malloc 时就会将 heap 切成两块 chunk，第一个 chunk 就是分配出去的 chunk，剩下的空间被视为 top chunk，之后要是分配空间不足时会有 top chunk 切出去 prev_size one_gadget strings 用 objdump 打开 libc.so.6 One Gadget: 0x4557a execve(“/bin/sh”, rsp+0x30, environ);"},{"title":"decompile_trick","date":"2022-05-18T14:43:16.000Z","url":"/2022/05/18/decompile/","content":" Tools or stricksobjdump 千万不要学AT&amp;T格式 -M intel: intel 格式 比较intel和AT&amp;T格式的反汇编区别vimdiff &lt;(objdump -d orw) &lt;(objdump -M intel -d orw) 建立快捷intel格式，alias objdump='objdump -M intel readelf 分析 ELF binary 功能 readelf -a | grep STACK 看能不能跑 shellcode E表示可以执行 stack上有x表示可以执行。 ldd 寻找 libc 的一些 symbol 比如 system。 小技巧 寻找某个 symbol 时，写成 ‘ symbol@’，假设 symbol 是某一个函数。 XXD 类似于 IDA pro 的 string Linux 自带的 strings 也不错 ncat Hook &amp; Patch 更改 symbol "},{"title":"fixed_xor","date":"2022-05-18T14:43:16.000Z","url":"/2022/05/18/fixed_cor/","content":" request a function to xor on two strings with the same length. we need know some tools ^: xor operator "},{"title":"HITCON-train-echo1","date":"2022-05-18T14:43:16.000Z","url":"/2022/05/18/echo1/","content":" 开始时会让我们输入在栈上的name，限制长度，bss段的id会复制name。"},{"title":"prctl","date":"2022-05-18T14:43:16.000Z","url":"/2022/05/18/prctl/","content":" "},{"title":"hex2base64","date":"2022-05-16T14:43:16.000Z","url":"/2022/05/16/hex2base64/","content":" I use Python to complete this play. If you don’t have it, you can try to download it and enjoy it. Given the hex string, hex string mean the base16 encode. base16 make each eight bit turn to two hex, then convert to three characters. use bytes.fromhex to unhexlify then use b64encode in base64 module Certainly, we want to write small program to use in the future. Then use some tricks to increase skill about module. def: def mean create a function to use repeatedly. __name__==\"__main__\": create a alone environment. "}]